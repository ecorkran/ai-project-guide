#!/bin/bash

# AI Project Guide - IDE Setup Script
# Copies project rules to your IDE configuration directory
# Supports: Cursor, Claude Code

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Script configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Find the actual project root by looking for project-documents directory
find_project_root() {
    local current_dir="$(pwd)"

    # Look for project-documents directory going up the directory tree
    local search_dir="$current_dir"
    while [[ "$search_dir" != "/" ]]; do
        if [[ -d "$search_dir/project-documents" ]]; then
            # Found project-documents, this is the project root
            echo "$search_dir"
            return
        fi
        search_dir="$(dirname "$search_dir")"
    done

    # If we're in the ai-project-guide standalone repo (no project-documents parent)
    if [[ "$SCRIPT_DIR" == */ai-project-guide/scripts ]]; then
        echo "$(dirname "$SCRIPT_DIR")"
        return
    fi

    # Fallback: assume current directory is project root
    echo "$current_dir"
}

PROJECT_ROOT="$(find_project_root)"
TARGET_ROOT="$PROJECT_ROOT"

# Set source directories
if [[ "$SCRIPT_DIR" == */ai-project-guide/scripts ]]; then
    # We're in the ai-project-guide source repository
    RULES_SOURCE_DIR="$SCRIPT_DIR/../project-guides/rules"
    AGENTS_SOURCE_DIR="$SCRIPT_DIR/../project-guides/agents"
else
    # We're in a project that includes ai-project-guide as submodule
    RULES_SOURCE_DIR="$PROJECT_ROOT/project-documents/ai-project-guide/project-guides/rules"
    AGENTS_SOURCE_DIR="$PROJECT_ROOT/project-documents/ai-project-guide/project-guides/agents"
fi

# Function to check if we're in the right directory
check_directory() {
    local current_dir=$(pwd)
    
    print_status $BLUE "üìç Project root detected: $PROJECT_ROOT"
    print_status $BLUE "üìç IDE directories will be created in: $TARGET_ROOT"
    echo ""
    
    # Warn if we're deep in subdirectories (might be confusing)
    if [[ "$current_dir" != "$PROJECT_ROOT" ]] && [[ "$current_dir" == */project-documents/* ]]; then
        print_status $YELLOW "üí° Note: You're running from inside project-documents/, but IDE files will be created in the project root."
        echo ""
    fi
}

# Function to show usage
show_usage() {
    echo "Usage: $0 <ide>"
    echo ""
    echo "Supported IDEs:"
    echo "  cursor    - Copy rules to .cursor/rules/ (renames .md to .mdc, converts paths to globs)"
    echo "  claude    - Embed alwaysApply rules in CLAUDE.md, copy others to .claude/rules/"
    echo ""
    echo "Examples:"
    echo "  $0 cursor"
    echo "  $0 claude"
    echo ""
    echo "This script copies AI project rules from project-guides/ to your IDE's"
    echo "configuration directory and validates frontmatter requirements."
}

# Function to print colored output
print_status() {
    local color=$1
    local message=$2
    echo -e "${color}${message}${NC}"
}

# Function to validate frontmatter
validate_frontmatter() {
    local file=$1
    local filename=$(basename "$file")
    
    if ! grep -q "^---" "$file"; then
        print_status $YELLOW "‚ö†Ô∏è  WARNING: $filename missing frontmatter"
        return 1
    fi
    
    if ! grep -q "description:" "$file"; then
        print_status $YELLOW "‚ö†Ô∏è  WARNING: $filename missing 'description' in frontmatter"
        return 1
    fi
    
    if ! grep -q "paths:" "$file" && ! grep -q "globs:" "$file" && ! grep -q "alwaysApply:" "$file"; then
        print_status $YELLOW "‚ö†Ô∏è  WARNING: $filename missing 'paths', 'globs', or 'alwaysApply' in frontmatter"
        return 1
    fi
    
    return 0
}

# Check if a rules file has alwaysApply: true in its frontmatter
has_always_apply() {
    local file=$1
    awk '
    BEGIN { in_frontmatter = 0 }
    /^---$/ {
        if (!in_frontmatter) { in_frontmatter = 1; next }
        else { exit 1 }
    }
    in_frontmatter && /^alwaysApply:[ ]*true/ { exit 0 }
    ' "$file"
}

# Convert paths frontmatter to Cursor globs format
# Input: source file with paths: YAML list
# Output: file with globs: JSON array format
convert_paths_to_globs() {
    local source_file=$1
    local target_file=$2

    awk '
    BEGIN { in_frontmatter = 0; in_paths = 0; path_count = 0 }
    /^---$/ {
        if (!in_frontmatter) {
            in_frontmatter = 1
            print
            next
        } else {
            # End of frontmatter ‚Äî output collected paths as globs
            if (path_count > 0) {
                printf "globs: ["
                for (i = 1; i <= path_count; i++) {
                    if (i > 1) printf ", "
                    printf "%s", paths[i]
                }
                printf "]\n"
            }
            in_frontmatter = 0
            in_paths = 0
            print
            next
        }
    }
    in_frontmatter {
        # Strip name field (not supported by Cursor)
        if (/^name:/) { next }
        if (/^paths:[ ]*$/) {
            # Start collecting paths entries
            in_paths = 1
            next
        }
        if (in_paths && /^[ ]+-[ ]+/) {
            # Collect path entry (keep quotes)
            path_count++
            val = $0
            sub(/^[ ]+-[ ]+/, "", val)
            paths[path_count] = val
            next
        }
        if (in_paths && !/^[ ]+-/) {
            # End of paths list, new field
            in_paths = 0
        }
        print
        next
    }
    { print }
    ' "$source_file" > "$target_file"
}

# Copy files with optional .mdc rename (used for agents and simple copies)
copy_files() {
    local source_dir=$1
    local target_dir=$2
    local rename_extension=$3
    local file_type=$4

    if [ ! -d "$source_dir" ]; then
        print_status $RED "‚ùå Source directory not found: $source_dir"
        return 1
    fi

    local copied_count=0

    for file in "$source_dir"/*.md; do
        if [ ! -f "$file" ]; then
            continue
        fi

        local filename=$(basename "$file")
        local target_filename="$filename"

        if [ "$rename_extension" = true ]; then
            target_filename="${filename%.md}.mdc"
        fi

        cp "$file" "$target_dir/$target_filename"
        print_status $GREEN "‚úÖ Copied $filename ‚Üí $target_filename"
        ((copied_count++))
    done

    print_status $BLUE "üìã Copied $copied_count $file_type files"
}

# Copy rules for Cursor: rename .md‚Üí.mdc and convert paths‚Üíglobs in frontmatter
copy_cursor_rules() {
    local source_dir=$1
    local target_dir=$2

    if [ ! -d "$source_dir" ]; then
        print_status $RED "‚ùå Source directory not found: $source_dir"
        return 1
    fi

    local copied_count=0
    local warning_count=0

    for file in "$source_dir"/*.md; do
        if [ ! -f "$file" ]; then
            continue
        fi

        local filename=$(basename "$file")
        local target_filename="${filename%.md}.mdc"
        local target_path="$target_dir/$target_filename"

        # Convert paths to globs format for Cursor
        convert_paths_to_globs "$file" "$target_path"
        print_status $GREEN "‚úÖ Converted $filename ‚Üí $target_filename"

        if ! validate_frontmatter "$target_path"; then
            ((warning_count++))
        fi

        ((copied_count++))
    done

    print_status $BLUE "üìã Converted $copied_count rule files for Cursor"
    if [ $warning_count -gt 0 ]; then
        print_status $YELLOW "‚ö†Ô∏è  $warning_count files have frontmatter issues"
    fi
}

# Compile alwaysApply rules into CLAUDE.md format
# Only processes files with alwaysApply: true in frontmatter
compile_claude_rules() {
    local source_dir=$1
    local target_file=$2

    if [ ! -d "$source_dir" ]; then
        print_status $RED "‚ùå Source directory not found: $source_dir"
        return 1
    fi

    print_status $BLUE "üìÑ Compiling alwaysApply rules into CLAUDE.md..."

    # Create CLAUDE.md file
    cat > "$target_file" << 'EOF'
# Project Guidelines for Claude

EOF

    local compiled_count=0

    for file in "$source_dir"/*.md; do
        if [ ! -f "$file" ]; then
            continue
        fi

        # Only embed alwaysApply files in CLAUDE.md
        if ! has_always_apply "$file"; then
            continue
        fi

        local filename=$(basename "$file")

        # Extract the main heading from the file to use as section title
        local section_title=$(awk '
        BEGIN { past_frontmatter = 0; in_frontmatter = 0; in_code = 0 }
        /^---$/ {
            if (!past_frontmatter) {
                in_frontmatter = !in_frontmatter
                if (!in_frontmatter) past_frontmatter = 1
                next
            }
        }
        in_frontmatter { next }
        /^```/ { in_code = !in_code; next }
        in_code { next }
        past_frontmatter && /^#{1,6} / {
            sub(/^#{1,6} /, "")
            print
            exit
        }
        ' "$file")

        # Add section heading
        if [ -n "$section_title" ]; then
            echo "## $section_title" >> "$target_file"
        else
            local fallback_title=$(echo "$filename" | sed 's/\.md$//' | sed 's/\b\w/\U&/g' | sed 's/-/ /g')
            echo "## $fallback_title Rules" >> "$target_file"
        fi

        # Extract content after frontmatter and heading, promoting heading levels
        awk '
        BEGIN { in_frontmatter = 0; past_frontmatter = 0; past_heading = 0; in_code = 0 }
        /^---$/ {
            if (!past_frontmatter) {
                in_frontmatter = !in_frontmatter
                if (!in_frontmatter) past_frontmatter = 1
                next
            }
        }
        in_frontmatter { next }
        /^```/ { in_code = !in_code }
        in_code { print; next }
        past_frontmatter && !past_heading && /^#{1,6} / { past_heading = 1; next }
        past_frontmatter && past_heading {
            if (/^#{2,6} /) {
                sub(/^#/, "")
            }
            print
        }
        ' "$file" >> "$target_file"

        echo "" >> "$target_file"
        print_status $GREEN "‚úÖ Embedded $(basename "$filename" .md) rules in CLAUDE.md"
        ((compiled_count++))
    done

    print_status $BLUE "üìã Embedded $compiled_count alwaysApply rules in CLAUDE.md"
    return 0
}

# Strip name field from frontmatter (not supported by Claude or Cursor rules)
strip_name_field() {
    local source_file=$1
    local target_file=$2

    awk '
    BEGIN { in_frontmatter = 0; past_frontmatter = 0 }
    /^---$/ {
        if (!past_frontmatter) {
            in_frontmatter = !in_frontmatter
            if (!in_frontmatter) past_frontmatter = 1
        }
        print
        next
    }
    in_frontmatter && /^name:/ { next }
    { print }
    ' "$source_file" > "$target_file"
}

# Copy non-alwaysApply rules to .claude/rules/ as modular rule files
copy_claude_modular_rules() {
    local source_dir=$1
    local target_dir=$2

    if [ ! -d "$source_dir" ]; then
        return 1
    fi

    mkdir -p "$target_dir"

    local copied_count=0

    for file in "$source_dir"/*.md; do
        if [ ! -f "$file" ]; then
            continue
        fi

        # Skip alwaysApply files (they go in CLAUDE.md)
        if has_always_apply "$file"; then
            continue
        fi

        local filename=$(basename "$file")
        strip_name_field "$file" "$target_dir/$filename"
        print_status $GREEN "‚úÖ Copied $filename ‚Üí .claude/rules/$filename"
        ((copied_count++))
    done

    print_status $BLUE "üìã Copied $copied_count modular rules to .claude/rules/"
}

# Main script logic
main() {
    # Check parameters
    if [ $# -eq 0 ]; then
        print_status $RED "‚ùå Error: IDE parameter required"
        echo ""
        show_usage
        exit 1
    fi
    
    local ide=$(echo "$1" | tr '[:upper:]' '[:lower:]')
    
    # Check if we're in the right directory
    check_directory "$1"
    
    # Validate IDE parameter
    case "$ide" in
        cursor|claude)
            ;;
        *)
            print_status $RED "‚ùå Error: Unsupported IDE '$1'"
            echo ""
            show_usage
            exit 1
            ;;
    esac
    
    # Handle Claude separately
    if [ "$ide" = "claude" ]; then
        print_status $BLUE "üöÄ Setting up Claude Code rules..."
        echo ""
        
        # Validate source directory exists
        if [ ! -d "$RULES_SOURCE_DIR" ]; then
            print_status $RED "‚ùå Error: Rules source directory not found: $RULES_SOURCE_DIR"
            print_status $YELLOW "üí° Make sure you're running this from a project that includes ai-project-guide"
            exit 1
        fi
        
        local claude_file="$TARGET_ROOT/CLAUDE.md"
        local claude_rules_dir="$TARGET_ROOT/.claude/rules"
        local claude_agents_dir="$TARGET_ROOT/.claude/agents"

        # Compile alwaysApply rules into CLAUDE.md
        if compile_claude_rules "$RULES_SOURCE_DIR" "$claude_file"; then
            echo ""

            # Copy modular rules to .claude/rules/
            print_status $BLUE "üìÑ Copying modular rules..."
            copy_claude_modular_rules "$RULES_SOURCE_DIR" "$claude_rules_dir"
            echo ""

            # Copy agents if directory exists
            if [ -d "$AGENTS_SOURCE_DIR" ]; then
                mkdir -p "$claude_agents_dir"
                print_status $GREEN "üìÅ Created directory: $claude_agents_dir"
                print_status $BLUE "ü§ñ Copying agent files..."
                copy_files "$AGENTS_SOURCE_DIR" "$claude_agents_dir" false "agent"
                echo ""
            fi

            print_status $GREEN "‚úÖ Setup complete for Claude Code!"
            echo ""
            print_status $BLUE "üí° Claude Code setup notes:"
            echo "   ‚Ä¢ CLAUDE.md contains alwaysApply rules (general, git)"
            echo "   ‚Ä¢ Modular rules copied to .claude/rules/"
            if [ -d "$AGENTS_SOURCE_DIR" ]; then
                echo "   ‚Ä¢ Agents copied to .claude/agents/"
            fi
        else
            print_status $RED "‚ùå Failed to compile CLAUDE.md"
            exit 1
        fi
        
        return 0
    fi
    
    # Cursor setup
    local rules_target_dir="$TARGET_ROOT/.cursor/rules"
    local agents_target_dir="$TARGET_ROOT/.cursor/agents"

    print_status $BLUE "üöÄ Setting up Cursor IDE rules..."
    echo ""

    # Validate source directories exist
    if [ ! -d "$RULES_SOURCE_DIR" ]; then
        print_status $RED "‚ùå Error: Rules source directory not found: $RULES_SOURCE_DIR"
        print_status $YELLOW "üí° Make sure you're running this from a project that includes ai-project-guide"
        exit 1
    fi

    # Create target directories
    mkdir -p "$rules_target_dir"
    print_status $GREEN "üìÅ Created directory: $rules_target_dir"

    # Copy rules with paths‚Üíglobs conversion
    print_status $BLUE "üìÑ Converting and copying rules files..."
    copy_cursor_rules "$RULES_SOURCE_DIR" "$rules_target_dir"

    echo ""

    # Copy agents if directory exists
    if [ -d "$AGENTS_SOURCE_DIR" ]; then
        mkdir -p "$agents_target_dir"
        print_status $GREEN "üìÅ Created directory: $agents_target_dir"
        print_status $BLUE "ü§ñ Copying agent files..."
        copy_files "$AGENTS_SOURCE_DIR" "$agents_target_dir" true "agent"
    else
        print_status $YELLOW "‚ö†Ô∏è  Agents directory not found, skipping"
    fi

    echo ""
    print_status $GREEN "‚úÖ Setup complete for Cursor!"
    echo ""
    print_status $BLUE "üí° Cursor setup notes:"
    echo "   ‚Ä¢ Rules converted to .cursor/rules/ as .mdc files (paths‚Üíglobs)"
    echo "   ‚Ä¢ Agents copied to .cursor/agents/ as .mdc files"
    echo "   ‚Ä¢ Restart Cursor to ensure rules are loaded"
}

# Run main function with all arguments
main "$@" 